<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>互動森林上色｜滑鼠/觸控筆刷（綠→黃、橘→紅）</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a2d; --bdr:#1c2a4a; --fg:#eaf6ff; --muted:#9eb3c9;
      --accent:#7fd7ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;}
    #wrap{position:fixed; inset:0; overflow:hidden}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none;}
    #ui{position:fixed; right:16px; top:16px; background:color-mix(in oklab, var(--panel) 92%, transparent); border:1px solid var(--bdr); border-radius:14px; padding:12px 14px; box-shadow:0 10px 30px rgba(0,0,0,.35); max-width:320px; backdrop-filter:saturate(1.2) blur(6px)}
    #ui h3{margin:0 0 8px; font-size:16px}
    #ui .row{display:grid; grid-template-columns: 1fr auto; align-items:center; gap:8px; margin:8px 0}
    #ui label{font-size:13px; color:var(--muted)}
    #ui input[type=range]{width:180px}
    #ui button, #ui .file{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--bdr); background:#0f1730; color:var(--fg); padding:8px 10px; border-radius:10px; cursor:pointer}
    #ui .hint{font-size:12px; color:var(--muted); line-height:1.3; margin-top:6px}
    #badge{position:fixed; left:12px; bottom:10px; font-size:12px; color:#9fb4cc; opacity:.8}
    a{color:var(--accent)}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="view"></canvas>
  </div>
  <div id="ui">
    <h3>互動森林上色（HTML）</h3>
    <div class="row">
      <label>筆刷大小 <span id="szVal">48</span>px</label>
      <input id="size" type="range" min="8" max="160" step="1" value="48" />
    </div>
    <div class="row">
      <label>力度 <span id="stVal">0.7</span></label>
      <input id="strength" type="range" min="0" max="1" step="0.01" value="0.7" />
    </div>
    <div class="row">
      <label>筆觸柔邊</label>
      <input id="soft" type="range" min="0.2" max="1.2" step="0.01" value="0.8" />
    </div>
    <div class="row">
      <button id="reset">重置DEMO背景</button>
      <label class="file">載入自訂背景<input id="file" type="file" accept="image/*" hidden></label>
    </div>
    <div class="hint">在畫面上拖曳即可上色。規則：<b>綠 → 黃</b>、<b>橘 → 紅</b>，其它色微暖化。雙擊畫面可切換全螢幕/退出。</div>
  </div>
  <div id="badge">DPR:<span id="dpr"></span> / 解析度自動對齊避免「只畫在左下角」錯位</div>

<script>
(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const ui = {
    size: document.getElementById('size'),
    strength: document.getElementById('strength'),
    soft: document.getElementById('soft'),
    szVal: document.getElementById('szVal'),
    stVal: document.getElementById('stVal'),
    file: document.getElementById('file'),
    reset: document.getElementById('reset'),
    dpr: document.getElementById('dpr'),
  };

  let DPR = Math.max(1, window.devicePixelRatio || 1);
  ui.dpr.textContent = DPR.toFixed(2);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * DPR);
    canvas.height = Math.round(rect.height * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // CSS像素座標→實際像素
    drawDemoForest();
    ui.dpr.textContent = DPR.toFixed(2);
  }

  window.addEventListener('resize', () => {
    // 提醒：resize 會重畫DEMO；若需保留畫面可在此先保存再貼回
    resize();
  });

  // --- DEMO 背景：簡易森林（綠葉/橘葉/樹幹/天空）---
  function drawDemoForest() {
    const w = canvas.width / DPR, h = canvas.height / DPR;
    // 天空漸層
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, '#c9e6ff');
    g.addColorStop(1, '#eaf3ff');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // 遠山
    ctx.fillStyle = '#aac7b0';
    for (let i=0;i<3;i++) {
      ctx.beginPath();
      const baseY = h*0.45 + i*18;
      ctx.moveTo(-50, baseY);
      for (let x=0; x<=w+50; x+=40) {
        const y = baseY - 30*Math.sin((x+i*70)/90) - 10*Math.cos((x)/35);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w+50, h);
      ctx.lineTo(-50, h);
      ctx.closePath();
      ctx.fill();
    }

    // 樹幹
    for (let i=0;i<12;i++){
      const x = (i/12)*w + (Math.sin(i*12.3)*0.5+0.5)*w/24;
      ctx.fillStyle = i%2? '#7c5a3a' : '#6d5033';
      ctx.fillRect(x, h*0.35, 10, h*0.65);
    }

    // 綠葉叢（色相約 100°）
    for (let i=0;i<100;i++){
      const x = Math.random()*w, y = h*0.2 + Math.random()*h*0.6;
      const r = 18+Math.random()*28;
      ctx.fillStyle = `hsl(${95+Math.random()*20} 50% ${35+Math.random()*20}%)`;
      blob(x,y,r,0.6);
    }
    // 橘色落葉區（色相約 25°）
    for (let i=0;i<45;i++){
      const x = Math.random()*w, y = h*0.6 + Math.random()*h*0.35;
      const r = 10+Math.random()*22;
      ctx.fillStyle = `hsl(${22+Math.random()*6} 70% ${45+Math.random()*20}%)`;
      blob(x,y,r,0.5);
    }

    function blob(cx,cy,r,alpha){
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.ellipse(cx,cy,r*1.1,r,0,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // --- 顏色工具 ---
  function rgb2hsv(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    const d=max-min;
    let h=0, s=max===0?0:d/max, v=max;
    if(d!==0){
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h/=6;
    }
    return {h,s,v}; // h 0..1
  }
  function hsv2rgb(h,s,v){
    let r, g, b;
    let i = Math.floor(h*6);
    let f = h*6 - i;
    let p = v*(1-s);
    let q = v*(1-f*s);
    let t = v*(1-(1-f)*s);
    switch(i%6){
      case 0: r=v,g=t,b=p; break;
      case 1: r=q,g=v,b=p; break;
      case 2: r=p,g=v,b=t; break;
      case 3: r=p,g=q,b=v; break;
      case 4: r=t,g=p,b=v; break;
      case 5: r=v,g=p,b=q; break;
    }
    return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)};
  }
  function clamp01(x){return x<0?0:(x>1?1:x)}

  // Hue 映射：綠→黃、橘→紅、其他微暖 (-10°)
  function mapHue(hDeg, s, v){
    let H = hDeg;
    if (H>80 && H<160){ // 綠域
      H = lerp(H, 60, 0.6); // 推向黃
      s = s*1.10; v = v*1.08;
    } else if (H>20 && H<40){ // 橘域
      H = lerp(H, 0, 0.65); // 推向紅
      s = s*1.05;
    } else {
      H = H - 10; // 微暖
    }
    // wrap 0..360
    H = (H%360+360)%360;
    return {H, s: clamp01(s), v: clamp01(v)};
  }
  function lerp(a,b,t){return a+(b-a)*t}
  function smoothstep(edge0, edge1, x){
    // 0..1
    const t = clamp01((x-edge0)/(edge1-edge0));
    return t*t*(3-2*t);
  }

  // --- 繪製（在局部取像素→改色→貼回）---
  let painting = false;
  let last = null;

  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left);
    const y = (evt.clientY - rect.top);
    return {x, y}; // CSS 像素座標（我們已用 setTransform 對齊）
  }

  function paintAt(cx, cy){
    const size = parseFloat(ui.size.value); // CSS px
    const strength = parseFloat(ui.strength.value);
    const softK = parseFloat(ui.soft.value); // 越大邊越軟

    const r = size; // 因 setTransform 已對齊，直接用 CSS px
    const x0 = Math.floor((cx - r));
    const y0 = Math.floor((cy - r));
    const w = Math.ceil(r*2);
    const h = Math.ceil(r*2);

    if (w<=0 || h<=0) return;

    // 抓局部像素
    const img = ctx.getImageData(x0, y0, w, h);
    const data = img.data; // RGBA

    for (let j=0; j<h; j++){
      for (let i=0; i<w; i++){
        const px = x0 + i;
        const py = y0 + j;
        const dx = px - cx;
        const dy = py - cy;
        const dist = Math.hypot(dx, dy);
        if (dist>r) continue;
        // 柔邊 alpha（中心1，邊緣0）
        const a = smoothstep(r, r*softK, dist); // softK < 1 較硬、>1 較軟
        if (a<=0) continue;

        const idx = (j*w + i)*4;
        const sr = data[idx], sg = data[idx+1], sb = data[idx+2], sa = data[idx+3];
        const hsv = rgb2hsv(sr, sg, sb);
        const hDeg = hsv.h*360;
        const mapped = mapHue(hDeg, hsv.s, hsv.v);
        const rgbNew = hsv2rgb((mapped.H/360), mapped.s, mapped.v);

        const k = a * strength; // 實際混合係數
        data[idx]   = Math.round(sr*(1-k) + rgbNew.r*k);
        data[idx+1] = Math.round(sg*(1-k) + rgbNew.g*k);
        data[idx+2] = Math.round(sb*(1-k) + rgbNew.b*k);
        data[idx+3] = sa; // 保留原alpha
      }
    }
    ctx.putImageData(img, x0, y0);
  }

  function strokeTo(p0, p1){
    const size = parseFloat(ui.size.value);
    const step = Math.max(2, size*0.35); // 取樣步長：半徑的~1/3，越小越密
    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    const dist = Math.hypot(dx, dy);
    const n = Math.ceil(dist/step);
    for (let s=0; s<=n; s++){
      const t = n? s/n : 1;
      paintAt(p0.x + dx*t, p0.y + dy*t);
    }
  }

  // 事件
  canvas.addEventListener('pointerdown', e=>{
    canvas.setPointerCapture(e.pointerId);
    painting = true;
    const p = getPointerPos(e);
    last = p;
    paintAt(p.x, p.y);
  });
  canvas.addEventListener('pointermove', e=>{
    if(!painting) return;
    const p = getPointerPos(e);
    if(last) strokeTo(last, p);
    last = p;
  });
  function endPaint(e){ painting=false; last=null; }
  canvas.addEventListener('pointerup', endPaint);
  canvas.addEventListener('pointercancel', endPaint);
  canvas.addEventListener('pointerleave', endPaint);

  // 全螢幕切換
  canvas.addEventListener('dblclick', ()=>{
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(()=>{});
    } else {
      document.exitFullscreen().catch(()=>{});
    }
  });

  // UI 綁定
  ui.size.addEventListener('input', ()=> ui.szVal.textContent = ui.size.value);
  ui.strength.addEventListener('input', ()=> ui.stVal.textContent = ui.strength.value);

  ui.reset.addEventListener('click', ()=>{
    drawDemoForest();
  });

  ui.file.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{
      // 將圖片等比鋪滿畫布（cover）
      const w = canvas.width / DPR, h = canvas.height / DPR;
      const iw = img.naturalWidth, ih = img.naturalHeight;
      const r = Math.max(w/iw, h/ih);
      const dw = iw*r, dh = ih*r;
      const dx = (w - dw)/2, dy = (h - dh)/2;
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(img, dx, dy, dw, dh);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });

  // 初始
  resize();
})();
</script>
</body>
</html>
